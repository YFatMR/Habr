# Кто такой Thread Pool и как его написать своими руками на С++

## Для кого статья?

Статья будет полезна всем, кто хочет окунуться в многопоточное программирование в С++, прочитано много теории, но всё ещё непонятно как использовать эти самые мьютексы на практике

## Что нового я могу узнать из статьи?

* Кто такой Thread Pool?
* 

## Кто такой Thread Pool?

Это удобный в использовании паттерн, позволяющая выполнять множество задач используя ресурсы множества потоков. Thread Pool состоит обычно из очереди задач и нескольких потоках, которые достают задачи из очереди и выполняют их параллельно

## Зачем использовать Thread Pool?

* Помогает увеличить производительность программы благодаря созданию потоков один раз (создание потока считается достаточно тяжёлой операцией)
* Предоставляет удобный интерфейс для работы с многопоточностью, который понятен человеку не знакомому с многопоточностью

## Немного цифр

Протестировав 3 случая: запуск без потоков, с созданием потоков через std::thread и с использованием thread_pool. На программе:

```
void test_func(int& res, const std::vector<int>& arr) {
    res = 0;
    for (int i = arr.size() - 1; i >= 0; --i) {
        for (int j = 0; j < arr.size(); ++j) {
            res += arr[i] + arr[j];
        }
    }
}
```

Получились следующие результаты:

| Способ запуска               | Время (миллисекунды) | Кол-во потоков |
|------------------------------|----------------------|----------------|
| Без потоков                  | 83954                | 1              |
| С использованием std::thred  | 62386                | 6              |
| С использованием thread_pool | 52474                | 6              |

Стоит отметить, что у меня на компьютере можно создать максимум 8 потоков и запускался тестовый пример в Visual Studio на платформе Windows. Это значит, что фоновая работа сторонних приложений может создавать флуктуации и при каждом запуске мы будем получать разные времена. (КОД ПРИМЕРОВ!!!)

## Почему 6 потоков не ускорили код в 6 раз?

системные прирывания, закон Амдала, возможное вмешательство других приложений

## Хорошо, но тогда как Thread Pool работает?

Thread Pool имеет очередь задач из которой каждый поток достаёт новую задачу при условии, что очередь не пуста и поток свободен. Для более детального описания давайте рассмотрим работу Thread Pool на примере

<b>Начальная стадия:</b> все потоки свободны, а в очереди присутствует 5 задач

<b>Стадия 1:</b> Каждый из потоков взял задачу на исполнение, при этом на практике первый поток не обязательно берёт первую задачу, это зависит от того, кто первый получит доступ к общему ресурсу - очереди (ПОЧЕМУ?). В очереди остались только 4 и 5 задача (чёрным цветом обозначены задачи, которые остались в очереди)

<b>Стадия 2:</b> На 3 секунде второй поток завершает выполнение 2 задачи и берёт первую свободную задачу из очереди (4 задачу). В очереди остаётся только 5 задача

<b>Стадия 3:</b> Третий поток завершил задачу 3 и взял последнюю задачу из очереди (5 задачу). Очередь стала пустой, но наша программа не должна завершать работу, сначала следует дождаться выполнения всех задач

<b>Стадия 4:</b> Первый поток завершил выполнение своей задачи и не берёт новых задач (т. к. очередь пуста). Может показаться, что если у нас нет задачи, когда мы закончили, то следующие задачи поток уже не выполняет. На самом деле это не так и как только придёт новая задача, свободный поток сразу начнёт её исполнение.

<b>Стадия 5:</b> Третий поток закончил выполнять задачу 5

<b>Стадия 6:</b> Второй поток закончил исполнение 4 задачи. 

<b>Итог:</b> Thread Pool выполнил 5 задач за 11 секунд.
